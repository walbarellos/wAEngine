* **UnitÃ¡rios** â†’ regras isoladas (QTE, builds, Elo).
* **IntegraÃ§Ã£o** â†’ mÃ³dulos conversando (Auth + Lobby, NetSync + Ranking).
* **End-to-End (E2E)** â†’ fluxo real (usuÃ¡rio â†’ partida â†’ resultado).

Mesmo que o cliente principal seja em **C++**, o **backend** (Node/Nest/Fastify) pode usar **Jest** (unit/integration) e **Cypress/Playwright** (E2E em UI web companion, APIs e simulaÃ§Ã£o de jogo).

---

# ğŸ§ª Plano de Testes por Requisito Funcional

---

## ğŸ® Jogabilidade & MecÃ¢nicas

### RF1 â€” Controle da pipa (movimento, habilidades)

* **UnitÃ¡rio:**

  * Testar `PlayerController.move()` responde corretamente a inputs.
  * Asserts: posiÃ§Ã£o Î” conforme direÃ§Ã£o + velocidade.
* **IntegraÃ§Ã£o:**

  * Cliente envia input â†’ NetSync â†’ mesmo estado reproduzido em 2 instÃ¢ncias.
* **E2E:**

  * Simular partida 1v1 â†’ mover pipa â†’ validar que HUD reflete energia gasta.

---

### RF2 â€” Duelo PrÃ©-Partida (QTE 10s)

* **UnitÃ¡rio:**

  * FunÃ§Ã£o `qte.evaluateHit(timing, window)` retorna score correto.
* **IntegraÃ§Ã£o:**

  * Jogador A e B enviam hits â†’ NetSync soma e calcula vencedor.
* **E2E:**

  * Rodar lobby â†’ duelo automÃ¡tico â†’ verificar que vencedor recebeu buff inicial.

---

### RF3 â€” QTEs contextuais (enganchos durante partida)

* **UnitÃ¡rio:** validar que funÃ§Ã£o `triggerQTE(collisionEvent)` dispara prompt.
* **IntegraÃ§Ã£o:** QTE emitido no cliente A aparece tambÃ©m no cliente B (consistÃªncia).
* **E2E:** Jogadores â€œcolidemâ€ â†’ ambos recebem QTE â†’ resultado igual nos 2 lados.

---

### RF4 â€” Feedback audiovisual (cortes, erros)

* **UnitÃ¡rio:**

  * FunÃ§Ã£o `hud.renderLineVibration()` altera intensidade conforme tensÃ£o.
* **IntegraÃ§Ã£o:** Evento de corte dispara `SoundFX.play("rasgo")` + `Particle.spawn("faÃ­sca")`.
* **E2E:** Jogador acerta QTE â†’ ver efeito de som/partÃ­cula renderizado.

---

## ğŸ† Modos de Jogo

### RF6 â€” 1v1 rÃ¡pido

* **UnitÃ¡rio:** `MatchFactory.create("1v1")` gera objeto vÃ¡lido.
* **IntegraÃ§Ã£o:** Lobby com 2 jogadores â†’ transiÃ§Ã£o `AGUARDANDOâ†’PRE_DUELOâ†’PARTIDA`.
* **E2E:** Jogadores jogam partida â†’ resultado salvo em DB.

---

### RF7 â€” Batalha de Bairro (4â€“8 jogadores)

* **UnitÃ¡rio:** validaÃ§Ã£o de limite `maxPlayers = 8`.
* **IntegraÃ§Ã£o:** NetSync processa inputs de 8 jogadores sem divergÃªncia.
* **E2E:** simular 8 bots â†’ partida completa sem queda de FPS.

---

### RF9 â€” Treino contra IA

* **UnitÃ¡rio:** funÃ§Ã£o `BotAI.tick(state)` retorna aÃ§Ãµes vÃ¡lidas.
* **IntegraÃ§Ã£o:** BotAI participa da partida e gera logs coerentes.
* **E2E:** Jogador entra em treino â†’ IA responde previsivelmente.

---

## ğŸ‘¥ Multiplayer & Lobbies

### RF10 â€” CriaÃ§Ã£o de lobby

* **UnitÃ¡rio:** `LobbyService.create()` gera cÃ³digo Ãºnico.
* **IntegraÃ§Ã£o:** DB registra lobby; jogadores podem ingressar.
* **E2E:** Jogador cria lobby via REST â†’ outro entra com cÃ³digo â†’ ambos conectados.

---

### RF12 â€” SincronizaÃ§Ã£o determinÃ­stica

* **UnitÃ¡rio:** `Lockstep.replay(inputs, seed)` gera mesmo estado em runs diferentes.
* **IntegraÃ§Ã£o:** 2 clientes recebem os mesmos inputs â†’ checksums iguais.
* **E2E:** Teste multi-instÃ¢ncia: partida longa sem divergÃªncia.

---

## ğŸ“Š Builds, ProgressÃ£o & Ranking

### RF14/15/16 â€” Escolha de pipa + linha = build

* **UnitÃ¡rio:** `Build.apply(pipa, linha)` retorna stats esperados.
* **IntegraÃ§Ã£o:** Build salva em DB e reaplicada em partida.
* **E2E:** Jogador cria build â†’ seleciona em lobby â†’ atributos refletem em partida.

---

### RF17 â€” Ranking/Elo

* **UnitÃ¡rio:** `elo.update(oldElo, result, opponentElo)` segue fÃ³rmula.
* **IntegraÃ§Ã£o:** Resultado de partida atualiza DB corretamente.
* **E2E:** Jogador vence â†’ ranking sobe â†’ GET `/rankings/me` reflete.

---

### RF18 â€” Recompensas cosmÃ©ticas

* **UnitÃ¡rio:** `RewardService.grant(skinId)` adiciona ao inventÃ¡rio.
* **IntegraÃ§Ã£o:** InventÃ¡rio persistido; UI exibe skin desbloqueada.
* **E2E:** Jogador termina missÃ£o â†’ recebe moeda/skin â†’ aparece em perfil.

---

## ğŸ¨ Interface & ExperiÃªncia

### RF20 â€” HUD minimalista

* **UnitÃ¡rio:** funÃ§Ã£o `HUD.renderBars()` respeita limites e cores.
* **IntegraÃ§Ã£o:** HUD atualiza em evento de corte.
* **E2E:** Jogador leva dano â†’ barra pisca vermelho na tela.

### RF22 â€” Acessibilidade

* **UnitÃ¡rio:** verificaÃ§Ã£o de contraste â‰¥ 4.5:1 (testes automatizados Lighthouse/axe).
* **IntegraÃ§Ã£o:** Controles remapeÃ¡veis salvos e aplicados.
* **E2E:** Jogador remapeia tecla â†’ input reconhecido corretamente.

---

# âš™ï¸ Ferramentas de Teste

* **UnitÃ¡rios/IntegraÃ§Ã£o (backend/serviÃ§os):**

  * **Jest** (TS/Node).
  * **Catch2/GoogleTest** (C++ client).

* **IntegraÃ§Ã£o DB/API:**

  * **Supertest** (REST APIs Nest/Fastify).
  * **Prisma Test Utils** (fixtures no PostgreSQL).

* **End-to-End:**

  * **Cypress** (fluxos web companion).
  * **Playwright** (multi-instÃ¢ncia para simulaÃ§Ã£o de lobbies/partidas).
  * **Custom test harness** em C++ para simular partidas determinÃ­sticas.

* **Acessibilidade:**

  * **axe-core**, **Lighthouse CI**.

---

# âœ… CritÃ©rios de AceitaÃ§Ã£o

* **Cobertura unitÃ¡ria â‰¥ 80%** em regras de negÃ³cio crÃ­ticas (QTE, builds, Elo).
* **Cobertura E2E mÃ­nima:**

  * Criar conta â†’ criar lobby â†’ duelo prÃ© â†’ partida â†’ resultado persistido.
  * Ranking atualizado e visÃ­vel.
* **Stress test:**

  * 8 jogadores simultÃ¢neos, 5 partidas seguidas â†’ FPS â‰¥ 60 e sem divergÃªncia lockstep.
* **SeguranÃ§a:**

  * Rate-limit testado com flood â†’ 429 retornado.
  * Inputs invÃ¡lidos â†’ 400 sem crash.

---
