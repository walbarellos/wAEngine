---

# ğŸ›ï¸ Arquitetura Geral

O *Pepeta Royale* serÃ¡ construÃ­do em **C++ (SDL2 + OpenGL)** no cliente, com **backend em Node.js/TypeScript (Nest/Fastify)** para serviÃ§os complementares (lobbies, ranking, persistÃªncia). O design segue **arquitetura em camadas**, separando **domÃ­nio, aplicaÃ§Ã£o e infraestrutura**.

---

## ğŸ”¹ Camadas e PapÃ©is

### 1. **Camada de ApresentaÃ§Ã£o (UI/UX)**

* **Responsabilidade:** input do jogador, HUD, menus, renderizaÃ§Ã£o 2D, efeitos visuais/sonoros.
* **PadrÃµes adotados:**

  * **MVC simplificado** â†’ separaÃ§Ã£o entre *Renderer (View)*, *Input Handler (Controller)* e *Estado do Jogo (Model)*.
  * **Observer/Event Bus** â†’ HUD reage a eventos do jogo (tensÃ£o, corte, vitÃ³ria QTE).
* **Tecnologias:**

  * **SDL2** (janela, input, Ã¡udio bÃ¡sico).
  * **OpenGL** (render 2D com batching e atlases de sprites).
  * **SDL\_mixer** para Ã¡udio de efeitos (rasgo, vento).

---

### 2. **Camada de DomÃ­nio (Game Core)**

* **Responsabilidade:** regras do jogo (movimento, QTE, builds, cortes, partidas).
* **PadrÃµes adotados:**

  * **Entity-Component-System (ECS)** â†’ leve, flexÃ­vel para gerenciar pipas, linhas, efeitos.
  * **State Machine (FSM)** â†’ controla estados (PrÃ©-Duelo â†’ Partida â†’ Resultado).
  * **Deterministic Lockstep** â†’ garante consistÃªncia entre clientes em multiplayer.
* **Tecnologias:**

  * **C++17/20**, cÃ³digo puro (sem dependÃªncias pesadas).
  * **RapidJSON / YAML-CPP** â†’ configs de builds, patch balance.
  * **Box2D opcional** (se quisermos fÃ­sica leve para colisÃµes simples).

---

### 3. **Camada de AplicaÃ§Ã£o (Rede e LÃ³gica de Partida)**

* **Responsabilidade:** sincronizaÃ§Ã£o multiplayer, matchmaking, persistÃªncia temporÃ¡ria de lobbies.
* **PadrÃµes adotados:**

  * **CQRS (Command Query Responsibility Segregation)**:

    * *Commands* = inputs do jogador enviados para todos.
    * *Queries* = leitura de estado validado (replays, ranking).
  * **Lockstep Input Replication** â†’ todos os clientes executam o mesmo cÃ³digo com os mesmos inputs.
* **Tecnologias:**

  * **Cliente:** ENet (UDP confiÃ¡vel) ou Asio.
  * **Servidor relay (fase 1):** Node.js (Fastify ou NestJS) + WebSockets/UDP bridge.
  * **Servidor autoritativo (fase 2):** valida inputs e resultados crÃ­ticos.

---

### 4. **Camada de PersistÃªncia (Dados e Ranking)**

* **Responsabilidade:** armazenamento de perfis, progressÃ£o, estatÃ­sticas de partidas.
* **PadrÃµes adotados:**

  * **DDD (Domain-Driven Design)** â†’ entidades centrais (Jogador, Pipa, Linha, Build, Partida, Temporada).
  * **RepositÃ³rio** â†’ abstrai acesso a dados.
* **Tecnologias:**

  * **PostgreSQL** â†’ dados relacionais (usuÃ¡rios, builds, partidas, ranking).
  * **Redis** â†’ cache (fila de matchmaking, estado de lobby, rate-limits).
  * **TypeORM / Prisma** â†’ mapeamento ORM no backend.

---

### 5. **Camada de Observabilidade & ManutenÃ§Ã£o**

* **Responsabilidade:** logs, mÃ©tricas, anti-cheat, deploy contÃ­nuo.
* **PadrÃµes adotados:**

  * **Circuit Breaker + Retry** em rede.
  * **Feature Flags** para ativar/desativar builds/efeitos sem redeploy.
* **Tecnologias:**

  * **Grafana + Prometheus** (telemetria de FPS, RTT, latÃªncia, QTE accuracy).
  * **Winston/Pino** (logs estruturados).
  * **Docker + Kubernetes** (deploy escalÃ¡vel de backend).

---

# ğŸ“Š PadrÃµes Globais

* **MVC** â†’ UI separada da lÃ³gica de jogo.
* **ECS** â†’ flexibilidade para adicionar pipas/skills sem quebrar o core.
* **FSM** â†’ estados do jogo (prÃ©-duelo, batalha, encerrado).
* **CQRS + Lockstep** â†’ consistÃªncia em rede e replays determinÃ­sticos.
* **DDD + RepositÃ³rio** â†’ clareza na modelagem do domÃ­nio.
* **Hot Reload de Configs** â†’ builds/efeitos balanceados via JSON/YAML.

---

# ğŸ› ï¸ Tecnologias por Componente

| Componente        | Tecnologia                                     |
| ----------------- | ---------------------------------------------- |
| Cliente (UI/Game) | C++17/20, SDL2, OpenGL, SDL\_mixer, ECS custom |
| Rede (Cliente)    | ENet (UDP confiÃ¡vel) / Boost.Asio              |
| Backend           | Node.js + Fastify/NestJS, Redis, PostgreSQL    |
| PersistÃªncia      | PostgreSQL, Redis, TypeORM/Prisma              |
| ConfiguraÃ§Ã£o      | JSON/YAML (RapidJSON/YAML-CPP)                 |
| Observabilidade   | Prometheus, Grafana, Pino/Winston              |
| Deploy            | Docker, Kubernetes, CI/CD pipeline             |

---

# âœ… BenefÃ­cios da Arquitetura

* **Clara separaÃ§Ã£o de responsabilidades** (UI, DomÃ­nio, Rede, PersistÃªncia).
* **Determinismo** â†’ garante justiÃ§a nas partidas e permite replays.
* **Escalabilidade** â†’ backend modular, pronto para autoritativo no futuro.
* **ManutenÃ§Ã£o simples** â†’ builds e balance em arquivos externos.
* **Robustez** â†’ seguranÃ§a desde a rede (rate-limit, checagem determinÃ­stica).

---
