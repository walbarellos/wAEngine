Perfeito, disc√≠pulo. Abaixo est√° o desenho **execut√°vel** da camada de servidor: **l√≥gica de neg√≥cios**, **rotas REST/GraphQL**, **autentica√ß√£o/autoriza√ß√£o** e **integra√ß√£o com banco** ‚Äî alinhado ao nosso DER e √† arquitetura modular (Auth, Lobby/Matchmaking, Net Sync, Ranking/Profile, Balance/Content, Telemetry/Anti-Cheat).

---

# üß† L√≥gica de Neg√≥cios (n√∫cleo)

## 1) Estados e Fluxos principais

* **Lobby FSM**: `CRIADO ‚Üí AGUARDANDO ‚Üí PRE_DUELO(10s) ‚Üí EM_ANDAMENTO ‚Üí ENCERRADO`.
* **Partida**:

  * **Pr√©-Duelo (10s)**: 3‚Äì5 QTEs; pontua√ß√£o = ‚àë acertos ponderados por efeitos da build.
  * **Vantagem inicial**:

    * `win_pre_duelo ‚áí +10% durabilidade` OU `energia cheia` OU `skill carregada`.
  * **Resultado**: vencedor/derrotado, estat√≠sticas (cortes, QTEs vencidos, dura√ß√£o).
* **MMR/Elo**:

  * Atualiza√ß√£o com **Glicko/Elo** simplificado:
    `new = old + K * (score - expected)` (K din√¢mico por incerteza).
* **Builds (pipa + linha)**:

  * Aplicadas por **config externa** (JSON): efeitos (ex.: cr√≠tico, regen, defesa) impactam:

    * **janela** de QTE (ms),
    * **peso** do acerto (score multiplier),
    * **perd√£o** (toler√¢ncia de erro).

## 2) Regras cr√≠ticas

* **Integridade de partida (lockstep)**:

  * Inputs em *ticks* numerados; `checksum` por *tick*.
  * Diverg√™ncia ‚áí solicitar `snapshot&rollback`.
* **Anti-Cheat QTE**:

  * Valida√ß√£o de tempo: `|t_cliente - t_servidor| < janela + toler√¢ncia(lat√™ncia)`.
  * Taxas an√¥malas (acerto >99% com jitter alto) ‚áí flag.

---

# üõ£Ô∏è Rotas REST (HTTP) ‚Äî *contratos enxutos*

Base URL: `https://api.pepeta.gg/v1`

## Auth & Perfil

* `POST /auth/signup` ‚Üí cria conta.
* `POST /auth/login` ‚Üí retorna `{ accessToken, refreshToken }`.
* `POST /auth/refresh` ‚Üí renova tokens.
* `GET /profile/me` (auth) ‚Üí perfil + invent√°rio.
* `PATCH /profile/me` (auth) ‚Üí altera nome/visuais.

## Lobbies & Matchmaking

* `POST /lobbies` (auth) ‚Üí cria lobby `{ id, code, type, hostAddr }`.
* `POST /lobbies/join` (auth) `{ code }` ‚Üí entra.
* `GET /lobbies/:id` (auth) ‚Üí status do lobby.
* `POST /lobbies/:id/start` (host) ‚Üí transita `AGUARDANDO ‚Üí PRE_DUELO`.
* `POST /lobbies/:id/leave` (auth) ‚Üí sair.

## Partidas

* `POST /matches/:id/qte/submit` (auth)
  Body: `{ tick, qteId, hitTimeMs, deviceLatencyMs }`
  Resp: `{ accepted: bool, scoreDelta }`
* `POST /matches/:id/result` (net-sync)
  Body: `{ winnerId, stats[], checksums[] }`
* `GET /matches/:id` (auth) ‚Üí resumo da partida.

## Ranking & Temporadas

* `GET /rankings/global?season=...`
* `GET /rankings/me` (auth)
* `GET /seasons/current` / `GET /seasons/:id`

## Builds & Conte√∫do

* `GET /content/builds` ‚Üí JSON de pipas, linhas, efeitos (cache√°vel/CDN).
* `POST /builds` (auth) ‚Üí cria/edita build do jogador.
* `GET /builds/mine` (auth)

## Telemetria

* `POST /telemetry/client` (auth) ‚Üí `{ fps, rtt, packetLoss, qteAcc }`.

> Todas as rotas **validam payload** (ex.: Zod/Valibot no gateway) e exigem **JWT** (exceto signup/login).

---

# üß© GraphQL (opcional/side-by-side)

Endpoint: `POST /graphql`

### Schema (recorte)

```graphql
type Query {
  me: Player!
  lobby(id: ID!): Lobby
  rankings(seasonId: ID, limit: Int = 100): [RankingEntry!]!
  buildsMine: [Build!]!
  contentBuilds: ContentBundle!
}

type Mutation {
  createLobby(type: LobbyType!): Lobby!
  joinLobby(code: String!): Lobby!
  startLobby(id: ID!): Lobby!
  submitQTE(matchId: ID!, qteId: ID!, hitTimeMs: Int!, deviceLatencyMs: Int!): QTEResult!
  saveBuild(input: BuildInput!): Build!
}
```

**Autoriza√ß√£o por *directives***:

```graphql
directive @auth(role: Role = USER) on FIELD_DEFINITION
```

(Resolvers verificam `ctx.user.role` e *claims* como `playerId`.)

---

# üîê Autentica√ß√£o & Autoriza√ß√£o

* **AuthN**: `JWT (access ~15min, refresh ~7d)`, `HS256/RS256`.
* **Fluxo**: login ‚Üí tokens; *silent refresh* no cliente.
* **AuthZ**:

  * RBAC m√≠nimo (`USER`, `MOD`, `ADMIN`).
  * **Host-only** para `POST /lobbies/:id/start`.
  * **Match-member** para `submitQTE`/`GET /matches/:id`.
* **Seguran√ßa**:

  * TLS/HSTS, CORS estrito, CSP (para web painel), SRI.
  * **Rate limit** IP/conta; *proof-of-work leve* em endpoints sens√≠veis.
  * **Audit log** p/ rotas estado cr√≠tico (start, result).

---

# üóÉÔ∏è Banco de Dados (PostgreSQL) ‚Äî *DER implementado*

## Tabelas (DDL abreviado)

```sql
CREATE TABLE jogador (
  id_jogador       UUID PRIMARY KEY,
  nome_usuario     TEXT UNIQUE NOT NULL,
  email            CITEXT UNIQUE NOT NULL,
  pass_hash        TEXT NOT NULL,
  elo_atual        INT DEFAULT 1000,
  moedas           INT DEFAULT 0,
  xp_total         BIGINT DEFAULT 0,
  data_criacao     TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE pipa (
  id_pipa UUID PRIMARY KEY,
  nome TEXT NOT NULL,
  tipo TEXT NOT NULL,
  stats_base JSONB NOT NULL,
  habilidade_passiva TEXT,
  descricao TEXT
);

CREATE TABLE linha (
  id_linha UUID PRIMARY KEY,
  nome TEXT NOT NULL,
  efeito TEXT NOT NULL,
  modificadores JSONB NOT NULL,
  descricao TEXT
);

CREATE TABLE build (
  id_build UUID PRIMARY KEY,
  id_jogador UUID REFERENCES jogador(id_jogador) ON DELETE CASCADE,
  id_pipa UUID REFERENCES pipa(id_pipa),
  id_linha UUID REFERENCES linha(id_linha),
  nome_custom TEXT,
  data_criacao TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE temporada (
  id_temporada UUID PRIMARY KEY,
  nome TEXT, data_inicio DATE, data_fim DATE, regras JSONB
);

CREATE TABLE pontuacao_temporada (
  id_jogador UUID REFERENCES jogador(id_jogador) ON DELETE CASCADE,
  id_temporada UUID REFERENCES temporada(id_temporada) ON DELETE CASCADE,
  elo INT, posicao INT,
  PRIMARY KEY (id_jogador, id_temporada)
);

CREATE TABLE lobby (
  id_lobby UUID PRIMARY KEY,
  codigo_convite TEXT UNIQUE NOT NULL,
  tipo TEXT CHECK (tipo IN ('publico','privado')) NOT NULL,
  host UUID REFERENCES jogador(id_jogador),
  status TEXT CHECK (status IN ('criado','aguardando','pre_duelo','em_andamento','encerrado')) NOT NULL
);

CREATE TABLE jogador_lobby (
  id_jogador UUID REFERENCES jogador(id_jogador) ON DELETE CASCADE,
  id_lobby UUID REFERENCES lobby(id_lobby) ON DELETE CASCADE,
  PRIMARY KEY (id_jogador, id_lobby)
);

CREATE TABLE partida (
  id_partida UUID PRIMARY KEY,
  id_lobby UUID REFERENCES lobby(id_lobby),
  modo TEXT CHECK (modo IN ('1v1','bairro','torneio')) NOT NULL,
  data TIMESTAMPTZ DEFAULT now(), duracao INT, resultado JSONB
);

CREATE TABLE participacao_partida (
  id_jogador UUID REFERENCES jogador(id_jogador) ON DELETE CASCADE,
  id_partida UUID REFERENCES partida(id_partida) ON DELETE CASCADE,
  id_build UUID REFERENCES build(id_build),
  resultado TEXT, cortes_feitos INT, qtes_vencidos INT,
  PRIMARY KEY (id_jogador, id_partida)
);

-- √çndices √∫teis
CREATE INDEX idx_build_jogador ON build(id_jogador);
CREATE INDEX idx_participacao_partida_partida ON participacao_partida(id_partida);
CREATE INDEX idx_pontuacao_temporada_elo ON pontuacao_temporada(elo);
```

> ORM sugerido no backend: **Prisma** (TS) ou **TypeORM** (Nest). Integra√ß√µes via **migrations**.

---

# üß™ Valida√ß√µes & Regras (exemplos)

## Zod (ou Joi) ‚Äì REST payloads

```ts
const submitQTESchema = z.object({
  qteId: z.string().uuid(),
  hitTimeMs: z.number().int().min(0).max(10000),
  deviceLatencyMs: z.number().int().min(0).max(1000),
  tick: z.number().int().min(0)
});
```

## Regra de neg√≥cio ‚Äî pontua√ß√£o do Pr√©-Duelo

```ts
// pseudo-code no Net Sync Service
score = 0
for each qte in window(10s):
  base = timingScore(hitTimeMs)         // 0..1 (ease)
  mod  = buildMods(qte, playerBuild)    // ex.: +critChance -> +0.1
  score += clamp(base * (1+mod), 0, 1.2)

winner = max(scoreA, scoreB)  // N: compara√ß√µes por par
grantAdvantage(winner)        // +durabilidade OU +energia OU skill carregada
```

## Atualiza√ß√£o de Elo (Elo cl√°ssico)

```ts
expected = 1 / (1 + 10 ** ((elo_oponente - elo_jogador) / 400))
newElo = elo_jogador + K * (score - expected)   // score ‚àà {1,0.5,0}
```

---

# üõ∞Ô∏è Integra√ß√£o entre servi√ßos

* **Cliente C++**:

  * Auth REST ‚Üí obt√©m JWT.
  * Lobby REST ‚Üí cria/entra e recebe endpoint UDP do **Net Sync**.
  * **UDP (ENet/Asio)** para inputs/ticks com Net Sync (lockstep determin√≠stico).
  * REST para Perfil/Ranking/Builds/Content; Telemetry POST ass√≠ncrono.

* **Net Sync Service**:

  * Recebe inputs, agrega por tick, envia *tick* consolidado.
  * Verifica `checksum` por *tick*; salva `match_result` ao final (REST ‚Üí Ranking).

* **Ranking/Profile**:

  * Recebe resultados, recalcula Elo, persiste `participacao_partida` e `pontuacao_temporada`.

* **Balance/Content**:

  * Servido por CDN; clientes fazem cache; *feature flags* ativam patches.

* **Telemetry/Anti-Cheat**:

  * Stream de eventos (NATS/Kafka); dashboards (Prometheus/Grafana); flags.

---

# üß± Middleware & Seguran√ßa (gateway)

* **Helmet/CSP**, **CORS** estrito, **HSTS**, **TLS**.
* **Rate limit** por IP/rota e **API keys** para servi√ßos internos.
* **Input validation** em todas as rotas (400 em erro).
* **Auditoria** (rota, userId, ip, payload hash).
* **Backoff/Retry** em chamadas inter-servi√ßos; **circuit breaker**.

---

# ‚úÖ Entreg√°veis imediatos (pr√≥ximos passos)

1. **OpenAPI 3.0** para todas as rotas REST acima.
2. **Schemas Prisma/TypeORM** com migrations das tabelas (DDL acima).
3. **Protos gRPC** (opcional) para Net Sync ‚Üî Ranking/Telemetry.
4. **Testes de contrato** (Supertest) e **teste determin√≠stico** de QTE (seedada).

Se quiser, eu j√° escrevo o **OpenAPI (YAML)** das rotas + os **schemas Prisma** para voc√™ colocar no reposit√≥rio e subir o primeiro backend skeleton.
